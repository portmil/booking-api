# Analyysi

## 1. Mitä tekoäly teki hyvin

### Pohjan luominen
GitHub Copilot (Free version) onnistui luomaan suhteellisen yksinkertaisen ohjeistuksen perusteella lähes toimivan sovelluksen. Siinä oli joitakin tyyppivirheitä ja muita ongelmia, jotka estivät koodin ajamisen heti ensimmäisen iteraation jälkeen, mutta kaikki peruspalikat olivat olemassa. Tekoäly on yleisestikin varsin hyvä luomaan boilerplate-koodia, vaikka alkuperäisen promptin suunnittelulla onkin paljon vaikutusta siihen, kuinka hyödyllinen tekoälyn tuotos on. Itse pidin mielenkiinnosta tarkoituksella tekniset yksityiskohdat vähäisinä ja sain silti varsin hyvän pohjan omalle työlleni. Ohjelmistokehittäjän onkin huomattavasti tehokkaampaa lähteä jalostamaan valmista pohjaa kuin aloittaa täysin tyhjästä. Mielenkiintoisena huomiona tekoälyn näyttää olevan äärimmäisen vaikea vastustaa kaikkien itsestäänselvyyksien kommentointia. Käskin sen varta vasten välttää itsestään selviä kommentteja, mutta silti se oli esimerkiksi lisännyt rivin `await initializeDatabase()` yläpuolelle selitykseksi `// Initialize database connection`.

### Yksikkötestien kirjoittaminen
Tekoäly osaa luoda ainakin yksikkötestien tapauksessa kattavan testisetin, joka huomioi hyvin erilaiset skenaariot. Lisäsin ehkä yhden tai kaksi testiä reunatapauksille, joita se ei ollut huomioinut, mutta muuten itse testitapauksiin ei tarvinnut juurikaan koskea. Jouduin korjaamaan lähinnä joitain tyyppivirheitä ja muokkaamaan sitä, miten se oli toteuttanut joitakin mockeja, sillä tekoälyn mockkaustapa aiheutti syntaksivirheitä Jestissä. Lisäksi sen tapa alustaa joitain testitapauksia ei huomioinut kaikkia validointeja, jolloin testit pysähtyivät validointivirheisiin. Vaadituista korjauksista huolimatta on huomattavasti tehokkaampaa antaa tekoälyn luoda pohjan testisetille ja korjata sen tekemät virheet samalla, kun varmistaa kaikkien tarvittavien testitapausten olevan mukana, kuin kirjoittaa testit alusta alkaen itse.

### Refaktoroinnin tehostaminen
Tekoälyn alkuperäisessä tuotoksessa kaikki endpointien koodi oli samassa tiedostossa aina niiden osoitteiden määrittelystä tietokantaoperaatioihin saakka. Kun käskin sen erottaa eri kerrokset toisistaan, jouduin korjailemaan muutaman virheen katsoessani koodin läpi, mutta tekoälyn apu nopeutti omaa työtäni verrattuna siihen, että olisin siirrellyt koodia kokonaan manuaalisesti tiedostosta toiseen.

### Uusien ideoiden esittely
Tekoäly voi osata ehdottaa sille esitetyn ongelman ratkaisemiseksi jotain tapaa tai syntaksia, jonka olemassaolosta ei itse ole ollut tietoinen. Toki aina pitää pysyä kriittisenä sille, onko sen ehdotus oikeasti järkevä tai edes olemassa oleva tapa, mutta välillä sen ehdotus voi olla parempi kuin mitä olisi itse osannut tehdä. Esimerkiksi `EXCLUDE USING GIST` oli minulle entuudestaan vieras, mutta siihen hieman (muualta kuin tekoälylähteestä) tutustuttuani totesin, että se vaikuttaa täydelliseltä työkalulta päällekkäisyystarkastuksen toteuttamiseen.

## 2. Mitä tekoäly teki huonosti
### Ylimääräisten ominaisuuksien lisääminen
Jätin alkuperäisessä promptissa tarkoituksella määrittelemättä esimerkiksi tietokannan rakenteen, sillä halusin nähdä, millaiseen ratkaisuun tekoäly päätyy. Mikäli kyseessä olisi ollut ”oikea” projekti, olisin suunnitellut tietokantataulut itse etukäteen ja määritellyt ne jo ensimmäiseen promptiin, jotta tekoäly olisi todennäköisemmin päätynyt jo aluksi järkevään ja käyttökelpoiseen ratkaisuun. Nyt se teki tietokantaan omia lisäyksiä, kuten huoneen kapasiteetti sekä varauksen osallistujamäärä ja otsikko. Nämä ideat eivät ole varsinaisesti tyhmiä, mutta vaatimustenmäärittelyssä ei ollut mitään niihin viittaavaa ja silti tekoäly lisäsi ne omin päin.

### Slonik-kirjaston käyttö
Halusin käyttää tietokanta clientina Slonikia, joka ei käsittääkseni ole mitenkään hirvittävän pienen piirin kirjasto, mutta ilmeisesti kuitenkin sen verran vähemmän tunnettu, että tekoälyllä oli vaikeuksia ymmärtää, miten ja millaisella syntaksilla sitä kuuluu käyttää. Suurimmat ongelmat tekoälyn alkuperäisen tuotoksen saamisessa ajettavaan kuntoon liittyivät juuri Slonikiin. Kun käskin Copilotin korjata virheet, sen muokkaukset saivat koodin entistä pahempaan solmuun, eikä sitä saanut vieläkään ajettua. Käännyin kokeeksi toisen tekoälyn puoleen ja pyysin apua ChatGPT:ltä, mutta senkään ehdotus ei tuottanut ajettavissa olevaa koodia. Lopulta päädyin itse tarkistamaan oikean syntaksin Slonikin dokumentaatiosta ja kerroin tekoälylle toimivan korjauksen, jotta pääsisin viimein siirtymään tehtävän kakkosvaiheeseen. Tämä oli hyvä muistutus siitä, että joskus tekoäly jää pyörimään kehää viemättä asiaa eteenpäin ja että etenkin vähemmän tunnettujen kirjastojen kanssa voi olla huomattavasti helpompaa löytää ratkaisu tavallisella googlaamisella tai itse dokumentaatiota lukemalla. Kysyin tekoälyltä Slonikiin liittyvän kysymyksen myös myöhemmin korjatessani manuaalisesti sen tekemiä syntaksivirheitä ja se alkoi taas johdattaa minua hakoteille.

### Kömpelöt korjaukset
Kun pyysin tekoälyä korjaamaan joitakin tyyppivirheitä tehtävän ykkösvaiheessa, se kyllä korjasi sille osoitetut virheet, mutta ei kovin elegantisti: sen ratkaisu oli type castaus anyyn ja type assertion. Tyyppivirheiden korjaaminen type assertionin tai any-tyyppiin muuttamisen avulla vesittää TypeScriptin idean, joten käskin tekoälyä keksimään toisen ratkaisun, jolloin se päätyi tukahduttamaan virheen kommentilla. Lopulta päätin, että olisi helpompaa olla vaatimatta tekoälyltä parempaa ratkaisua tässä vaiheessa ja antaa asian olla, kunnes pääsen kakkosvaiheeseen ja minulla on lupa koskea koodiin itse.

### Konfiguraatiot
Automaattinen konfiguraation generointi on vähän kaksipiippuinen juttu, joka voisi kuulua molempien otsikoiden alle. Toisaalta yksi tekoälyn suurimmista vahvuuksista on juuri boilerplate-koodin luominen, jollaiseksi konfiguraatiotiedostotkin voi tavallaan mieltää. Tekoälyn luoma konfiguraatio siis nopeuttaa kehitystä, mutta voi myös johtaa vaikeasti jäljitettäviin tai korjattaviin virheisiin. Olin tyhmästi ajanut sovellusta vain kehitystilassa, joten huomasin vasta varsin myöhään, että tekoälyn ensimmäisessä vaiheessa luomat konfiguraatiotiedostot olivat keskenään ristiriidassa, mikä esti ajamasta sovellusta tuotantotilassa. Tekoäly voi olla hyvinkin nopea huomaamaan ja korjaamaan konfiguraatiovirheitä, mutta tässä tilanteessa pallottelin pitkään Copilotin kanssa ongelman ratkaistakseni. Tekoälyn korjausehdotukset aiheuttivat kuitenkin lumipalloefektin, jossa yhden ongelman korjaaminen rikkoi vuoron perään npm startin, Knex-migraatiot ja Jestin. Lopulta tajusin, että alkuperäisen kysymykseni sanamuoto ohjasi tekoälyä ratkaisuihin, jotka aiheuttivat vain uusia ongelmia, ja että tässä tilanteessa järkevin ratkaisu oli paljon yksinkertaisempi kuin AI:n ehdottamat.

## 3. Tärkeimmät parannukset tekoälyn tuottamaan koodiin
### Tiedostorakenteen refaktorointi
En alkuperäisessä promptissa käskenyt erotella eri toiminnallisuuksia eri tiedostoihin, joten tekoälyn luomassa alkuperäisessä rakenteessa kaikki endpointien koodi oli samassa tiedostossa. Oikeassa tuotantoprojektissa tämä yksinkertainen rakenne tulisi hyvin nopeasti hankalaksi ylläpitää, sillä sovelluksessa olisi todennäköisesti enemmän kuin kolme endpointia. Yksi näkyvimmistä parannuksista onkin "separation of concerns" ja kerrokselliseen arkkitehtuuriin (router, controller, service, repository) siirtyminen. Ylläpidettävyyden ja skaalautuvuuden ohella refaktoroitua rakennetta on myös helpompi testata ja tarvittaessa debugata.

### Paremmat käytännöt
Lopullinen ratkaisuni noudattaa parempia koodauskäytäntöjä kuin tekoälyn alkuperäinen tuotos. Näistä yhtenä esimerkkinä on jo aiemmin mainittujen type assertionien välttäminen, joita lopullisesta koodista löytyy enää vain testitiedostoista.

### Päällekkäisyystarkastuksen korjaaminen
Tekoälyn luomassa päällekkäisyystarkastuksessa oli kaksikin ongelmaa: logiikkavirhe ja mahdollinen kilpailutilanne (race condition).

#### Logiikkavirhe
Aivan alkuperäisessä koodissa varausten päällekkäisyyden tarkistamiseen käytetty logiikka näyttää olevan kunnossa, mutta jotenkin logiikka pääsi muuttumaan, kun käskin tekoälyä siirtämään tietokantaoperaatiot omaan moduuliinsa. Lopputulos oli, että tarkistus huomasi vain tapaukset, joissa olemassa oleva varaus peittää uuden varauksen kokonaan. Korjasin logiikan jälleen niin, että se huomaa myös tilanteet, joissa varaukset ovat vain osittain päällekkäin.

#### Kilpailutilanne
Tekoäly ei huomioinut varauksen luomiseen liittyvää mahdollista kilpailutilannetta. Sen ratkaisussa varausten päällekkäisyys tarkistetaan erillisellä tietokantakyselyllä, jonka jälkeen uusi varaus lisätään tietokantaan. Tämä kuitenkin mahdollistaa tilanteen, jossa kaksi requestia saapuu hyvin lähellä toisiaan ja yrittää tehdä varauksen, jotka menisivät päällekkäin. Molemmat operaatiot näkisivät, että huone on yhä vapaana ja lisäävät varauksen tietokantaan, jonka jälkeen samaan huoneeseen onkin päällekkäiset varaukset. Siirsin päällekkäisyystarkistuksen tietokantarajoitteeksi, jolloin samanaikaiset requestitkaan eivät pääse luomaan päällekkäisiä varauksia.
